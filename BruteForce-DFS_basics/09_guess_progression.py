# 9. 수열 추측하기(순열, 파스칼 응용)
# 문제 : 가장 윗줄에 1부터 N까지의 숫자가 한 개씩 적혀 있고, 둘째 줄부터 차례대로 파스칼의 삼각형처럼 위의 두 개를 더한 값이 저장됨
#        N과 가장 밑에 있는 숫자가 주어졌을 때, 삼각형의 가장 윗줄에 들어갈 N개의 숫자를 빈칸을 사이에 두고 출력
#        단, 답이 여러 가지가 나오는 경우 사전 순으로 가장 앞에 오는 것을 출력. 답이 존재하지 않는 경우는 입력으로 주어지지 않음
# 조건 : 두 개의 정수 N(1 <= N <= 10)과 F가 주어짐. N은 가장 윗줄에 있는 숫자의 개수를 의미하며 F는 가장 밑에 줄에 있는 수로 1,000,000 이하임
# 회고 : 문제 접근 방법을 아예 생각해 내지 못함
#        단순히 완전 탐색으로 순열을 구할 수 있으나, n = 10인 경우 가짓수가 10!(360만)개라 비효율적임
#        따라서 수학적인 규칙을 찾아야 함. 여기서는 수열의 각 숫자가 더해지는 횟수가 이항계수임을 활용함
#        이항계수의 양쪽 맨 끝은 무조건 1임

# Solution_1
import sys


def DFS(l, sum):
    if l == n and sum == f:
        for x in p:
            print(x, end=" ")
        sys.exit(0)  # 최초로 발견된 수열을 출력 후 프로그램 종료
    else:
        for i in range(1, n + 1):
            if ch[i] == 0:
                ch[i] = 1
                p[l] = i  # p[l] : 수열의 원소 값
                DFS(l + 1, sum + (p[l] * b[l]))  # p[l] * b[l] : 원소 * 이항계수
                ch[i] = 0  # 다른 가닥에서 다시 쓸 수 있게 0으로 되돌림


if __name__ == "__main__":
    n, f = map(int, input().split())
    p = [0] * n  # 수열을 만들 곳 [0, 0, 0, 0]
    b = [1] * n  # 이항계수 초기화 [1, 1, 1, 1]. 맨 끝은 바꿀 필요 없음
    ch = [0] * (n + 1)  # 중복을 방지하기 위한 check list [0, 0, 0, 0, 0]
    for i in range(1, n):
        b[i] = b[i - 1] * (n - i) // i  # 초기화 효과
    DFS(0, 0)


# test_case 1
# n, f = 4 16
# result : 3 1 2 4

# test_case 2
# n, f = 5 39
# result : 4 1 3 2 5

# test_case 3
# n, f = 9 1610
# result : 1 2 3 5 9 6 8 4 7
