# 4. 합이 같은 부분집합(DFS : 아마존 인터뷰)
# 문제 : N개의 원소로 구성된 자연수 집합이 주어지면, 이 집합을 두 개의 부분집합으로 나누었을 때
#        두 부분집합의 원소의 합이 서로 같은 경우가 존재하면 "YES"를 출력하고, 그렇지 않으면
#        "NO"를 출력하는 프로그램을 작성
#        둘로 나뉘는 두 부분집합은 서로소 집합이며, 두 부분집합을 합하면 입력으로 주어진 원래의 집합이 됨
#        예를 들어 {1, 3, 5, 6, 7, 10}이 입력되면 {1, 3, 5, 7} = {6, 10}으로 두 부분집합의 합이
#        16으로 같은 경우가 존재하는 것을 알 수 있음
# 조건 : 첫 번째 줄에 자연수 N(1 <= N <= 10)이 주어짐
#        두 번째 줄에 집합의 원소 N개가 주어짐. 각 원소는 중복되지 않음
# 회고 : 숫자가 그냥 1, 2, 3 이렇게 커지는 게 아니라 주어진 원소들로 부분집합을 구성해야 함(원소가 랜덤으로 주어짐)
# 2^6의 경우의 수가 생김 = 64가지(공집합 빼면 63가지)

# 두 개의 부분집합으로 나눈다는 건, 맨 처음부터 맨 끝에 것은 포함하면 안 되는 건가..?
# 그렇다기엔 다른 경우의 수에서 그 마지막이 쓰일 수 있음.
# 1일 떄와 0일 떄의 부분집합으로 나눴을 때, 각 부분집합의 길이가 1 이상인 경우로 해야할 듯?
# 들어가야 하는 변수가 시작하는 첫 번째 값, nums가 있어야 거기 있는 숫자대로 돌아갈테고, 깊이를 파악하는 것일 듯

# 변수 길이에 따른 인덱스 범위가 헷갈려서 디버깅 하기 전까지 숫자를 잘못 가져옴
# DFS에서 return을 한 번 한 뒤 아예 함수를 종료시키고 싶은데 어떻게 하는지 잘 모름
# 전역변수 yes를 글로벌로 로컬 변수처리 해주야 함

# My_solution -> (성공)
def DFS(v, nums):
    global yes
    if v == (n + 1):
        zero = 0
        one = 0
        for i in range(1, n + 1):  # 0으로 표시된 것과 1로 표시된 것들을 각각 더해줌
            if ch[i] == 0:
                zero += nums[i - 1]  # 입력으로 받은 자연수 집합은 idx가 0부터 시작
            else:
                one += nums[i - 1]
        if zero == one:  # 두 부분집합의 원소의 합이 같을 경우 표시
            yes += 1
    else:
        ch[v] = 1
        DFS(v + 1, nums)
        ch[v] = 0
        DFS(v + 1, nums)


if __name__ == "__main__":
    n = int(input())
    nums_set = list(map(int, input().split()))
    ch = [0] * (n + 1)
    yes = 0
    DFS(1, nums_set)

    if yes >= 1:
        print("YES")
    else:
        print("NO")


# test_case 1
# n = 6
# nums = 1 3 5 6 7 10
# result : YES

# test_case 2
# n = 7
# nums = 1 2 3 4 5 6 7
# result : YES

# test_case 3
# n = 9
# nums = 3 6 13 11 7 16 34 23 12
# result : NO
